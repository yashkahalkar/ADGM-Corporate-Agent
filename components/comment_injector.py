from docx import Document
from docx.oxml import parse_xml
from docx.oxml.ns import nsdecls
from docx.shared import Inches
import os
import tempfile
from typing import List, Dict, Any
import re

class CommentInjector:
    def __init__(self):
        self.comment_counter = 0
    
    def add_comments(self, doc_path: str, issues: List[Dict[str, Any]]) -> str:
        """Add comments to Word document based on issues found"""
        try:
            # Create a copy of the document
            doc = Document(doc_path)
            
            # Reset comment counter
            self.comment_counter = 0
            
            # Group issues by location for better organization
            location_issues = self._group_issues_by_location(issues)
            
            # Add comments to document
            for location, issue_list in location_issues.items():
                self._add_comment_to_location(doc, location, issue_list)
            
            # Save commented document
            output_path = self._create_output_path(doc_path)
            doc.save(output_path)
            
            return output_path
            
        except Exception as e:
            raise Exception(f"Error adding comments to document: {str(e)}")
    
    def _group_issues_by_location(self, issues: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """Group issues by their location in the document"""
        location_groups = {}
        
        for issue in issues:
            location = issue.get('location', 'General')
            if location not in location_groups:
                location_groups[location] = []
            location_groups[location].append(issue)
        
        return location_groups
    
    def _add_comment_to_location(self, doc: Document, location: str, issues: List[Dict[str, Any]]):
        """Add comment to specific location in document"""
        # Create comment text
        comment_text = self._create_comment_text(issues)
        
        # Find the best paragraph to attach comment to
        target_paragraph = self._find_target_paragraph(doc, location, issues)
        
        if target_paragraph:
            self._insert_comment(target_paragraph, comment_text, issues[0]['severity'])
    
    def _create_comment_text(self, issues: List[Dict[str, Any]]) -> str:
        """Create formatted comment text from issues"""
        comment_lines = []
        comment_lines.append("ðŸ” ADGM COMPLIANCE REVIEW")
        comment_lines.append("=" * 30)
        
        for i, issue in enumerate(issues, 1):
            severity_icon = {
                'High': 'ðŸ”´',
                'Medium': 'ðŸŸ¡', 
                'Low': 'ðŸŸ¢'
            }.get(issue['severity'], 'ðŸ”µ')
            
            comment_lines.append(f"\n{i}. {severity_icon} {issue['issue']}")
            comment_lines.append(f"   Severity: {issue['severity']}")
            comment_lines.append(f"   Category: {issue['category']}")
            comment_lines.append(f"   ðŸ’¡ Suggestion: {issue['suggestion']}")
            
            if 'matched_text' in issue:
                comment_lines.append(f"   ðŸ“ Found: '{issue['matched_text']}'")
        
        comment_lines.append("\n" + "=" * 30)
        comment_lines.append("Generated by ADGM Corporate Agent")
        
        return '\n'.join(comment_lines)
    
    def _find_target_paragraph(self, doc: Document, location: str, issues: List[Dict[str, Any]]) -> object:
        """Find the most appropriate paragraph to attach the comment"""
        # Try to find paragraph by location description
        if 'Paragraph' in location:
            # Extract paragraph number
            match = re.search(r'Paragraph (\d+)', location)
            if match:
                para_num = int(match.group(1)) - 1  # Convert to 0-based index
                if 0 <= para_num < len(doc.paragraphs):
                    return doc.paragraphs[para_num]
        
        # Try to find by content matching
        for issue in issues:
            if 'matched_text' in issue:
                matched_text = issue['matched_text'].lower()
                for paragraph in doc.paragraphs:
                    if matched_text in paragraph.text.lower():
                        return paragraph
        
        # Try to find by keyword matching
        keywords = self._extract_keywords_from_location(location)
        for keyword in keywords:
            for paragraph in doc.paragraphs:
                if keyword.lower() in paragraph.text.lower():
                    return paragraph
        
        # Fallback: return first paragraph with substantial content
        for paragraph in doc.paragraphs:
            if len(paragraph.text.strip()) > 20:
                return paragraph
        
        # Last resort: return first paragraph
        return doc.paragraphs[0] if doc.paragraphs else None
    
    def _extract_keywords_from_location(self, location: str) -> List[str]:
        """Extract keywords from location description"""
        keywords = []
        
        # Common legal document sections
        section_keywords = {
            'signature': ['signature', 'signed', 'witness'],
            'jurisdiction': ['jurisdiction', 'court', 'governing law'],
            'articles': ['articles', 'clause', 'section'],
            'memorandum': ['memorandum', 'objects', 'capital'],
            'resolution': ['resolution', 'resolved', 'directors'],
            'date': ['date', 'dated', 'day of']
        }
        
        location_lower = location.lower()
        for section, section_keywords_list in section_keywords.items():
            if section in location_lower:
                keywords.extend(section_keywords_list)
        
        # Add any quoted text from location
        quoted_matches = re.findall(r"'([^']*)'|\"([^\"]*)\"", location)
        for match in quoted_matches:
            keywords.extend([m for m in match if m])
        
        return keywords
    
    def _insert_comment(self, paragraph, comment_text: str, severity: str):
        """Insert comment into paragraph"""
        try:
            self.comment_counter += 1
            
            # Highlight the paragraph based on severity
            self._highlight_paragraph(paragraph, severity)
            
            # Add comment marker at the beginning of paragraph
            comment_marker = f" [ADGM-{self.comment_counter}] "
            
            if paragraph.runs:
                # Insert at beginning of first run
                first_run = paragraph.runs[0]
                first_run.text = comment_marker + first_run.text
                
                # Make marker bold and colored
                first_run.bold = True
                first_run.font.color.rgb = self._get_severity_color(severity)
            else:
                # Create new run if no runs exist
                run = paragraph.add_run(comment_marker)
                run.bold = True
                run.font.color.rgb = self._get_severity_color(severity)
            
            # Note: Word document comments require more complex implementation
            # For now, we'll add the comment text as a highlighted paragraph
            self._add_comment_paragraph(paragraph, comment_text, severity)
            
        except Exception as e:
            print(f"Error inserting comment: {str(e)}")
    
    def _highlight_paragraph(self, paragraph, severity: str):
        """Highlight paragraph based on severity"""
        from docx.enum.text import WD_COLOR_INDEX
        
        severity_highlights = {
            'High': WD_COLOR_INDEX.PINK,
            'Medium': WD_COLOR_INDEX.YELLOW,
            'Low': WD_COLOR_INDEX.BRIGHT_GREEN
        }
        
        highlight_color = severity_highlights.get(severity, WD_COLOR_INDEX.GRAY_25)
        
        for run in paragraph.runs:
            try:
                run.font.highlight_color = highlight_color
            except:
                pass  # Ignore if highlighting fails
    
    def _get_severity_color(self, severity: str):
        """Get RGB color for severity"""
        from docx.shared import RGBColor
        
        severity_colors = {
            'High': RGBColor(220, 53, 69),    # Red
            'Medium': RGBColor(255, 193, 7),   # Yellow/Orange
            'Low': RGBColor(40, 167, 69)       # Green
        }
        
        return severity_colors.get(severity, RGBColor(108, 117, 125))  # Gray
    
    def _add_comment_paragraph(self, target_paragraph, comment_text: str, severity: str):
        """Add comment as a separate paragraph after target"""
        try:
            # Get the parent element
            parent = target_paragraph._element.getparent()
            target_index = list(parent).index(target_paragraph._element)
            
            # Create comment paragraph
            from docx.oxml.shared import qn
            comment_p = parent.makeelement(qn('w:p'))
            
            # Add comment content
            comment_run = comment_p.makeelement(qn('w:r'))
            comment_text_elem = comment_run.makeelement(qn('w:t'))
            comment_text_elem.text = f"\nðŸ’¬ COMMENT: {comment_text}\n"
            comment_run.append(comment_text_elem)
            comment_p.append(comment_run)
            
            # Insert after target paragraph
            parent.insert(target_index + 1, comment_p)
            
        except Exception as e:
            print(f"Error adding comment paragraph: {str(e)}")
    
    def _create_output_path(self, original_path: str) -> str:
        """Create output path for commented document"""
        directory = os.path.dirname(original_path)
        filename = os.path.basename(original_path)
        name, ext = os.path.splitext(filename)
        
        # Create timestamped filename
        from datetime import datetime
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        
        output_filename = f"{name}_commented_{timestamp}{ext}"
        return os.path.join(directory, output_filename)
    
    def create_summary_document(self, issues: List[Dict[str, Any]], output_dir: str) -> str:
        """Create a summary document with all issues"""
        try:
            # Create new document
            doc = Document()
            
            # Add title
            title = doc.add_heading('ADGM Compliance Analysis Summary', 0)
            
            # Add summary statistics
            from datetime import datetime
            doc.add_paragraph(f'Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}')
            doc.add_paragraph(f'Total Issues Found: {len(issues)}')
            
            # Group by severity
            severity_groups = {}
            for issue in issues:
                severity = issue['severity']
                if severity not in severity_groups:
                    severity_groups[severity] = []
                severity_groups[severity].append(issue)
            
            # Add severity breakdown
            doc.add_heading('Issues by Severity', level=1)
            for severity in ['High', 'Medium', 'Low']:
                if severity in severity_groups:
                    count = len(severity_groups[severity])
                    doc.add_paragraph(f'{severity} Priority: {count} issues')
            
            # Add detailed issues
            doc.add_heading('Detailed Issues', level=1)
            
            for severity in ['High', 'Medium', 'Low']:
                if severity in severity_groups:
                    doc.add_heading(f'{severity} Priority Issues', level=2)
                    
                    for i, issue in enumerate(severity_groups[severity], 1):
                        issue_para = doc.add_paragraph()
                        issue_para.add_run(f"{i}. ").bold = True
                        issue_para.add_run(issue['issue'])
                        
                        doc.add_paragraph(f"Location: {issue['location']}", style='List Bullet')
                        doc.add_paragraph(f"Category: {issue['category']}", style='List Bullet')
                        doc.add_paragraph(f"Suggestion: {issue['suggestion']}", style='List Bullet')
                        
                        if 'matched_text' in issue:
                            doc.add_paragraph(f"Found Text: '{issue['matched_text']}'", style='List Bullet')
                        
                        doc.add_paragraph()  # Add spacing
            
            # Save summary document
            output_path = os.path.join(output_dir, f'ADGM_Compliance_Summary_{datetime.now().strftime("%Y%m%d_%H%M%S")}.docx')
            doc.save(output_path)
            
            return output_path
            
        except Exception as e:
            raise Exception(f"Error creating summary document: {str(e)}")
